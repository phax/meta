/**
 * Copyright (C) 2014-2020 Philip Helger (www.helger.com)
 * philip[at]helger[dot]com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package blindsignature;

import java.math.BigInteger;
import java.security.SecureRandom;

import com.helger.commons.random.VerySecureRandom;

/**
 * VotingClient is a client-side of blind signature voting module.
 *
 * @author Pawel Maniora
 */
public class VotingClient
{

  /**
   * number of candidates on voting cards
   */
  private final int m_nCandidates;

  /**
   * numbers of cards - the higher amount - the safer and slower voting is.
   */
  private final int m_nCardamount;

  /**
   * public key encriptor. everybody who wants use it to encrypt message
   */
  private final BigInteger m_aE;

  /**
   * modulus used in encryption/decryption. everybody who wants use it
   */
  private final BigInteger m_aMod;

  /**
   * all cards used to vote in plain format
   */
  private BigInteger [] [] m_aCards;

  /**
   * all blind cards
   */
  private BigInteger [] [] m_aEncodedCards;

  /**
   * set of r. One r for each card used to make blinding factor
   */
  private BigInteger [] r;

  /**
   * set of inverted r used to remove blinding factor
   */
  private BigInteger [] rprim;

  /**
   * inverted r used to remove blinding factor from signed card saved in another
   * place than rprim set to send full rprim set to server
   */
  private BigInteger m_aRfinal;

  /**
   * card signed by private key of server
   */
  private BigInteger [] m_aSignedCard;

  /**
   * voting client constructor
   */
  VotingClient (final int candidates, final int cardamount, final BigInteger e, final BigInteger mod)
  {
    this.m_nCandidates = candidates;
    this.m_nCardamount = cardamount;
    this.m_aE = e;
    this.m_aMod = mod;
    this.generateCards ();
    this.generateBlindingFactors ();
    this.generateUnblindingFactors ();
    this.encodeCards ();
    this.m_aRfinal = null;
    this.m_aSignedCard = null;
  }

  /**
   * gemerate voting cards
   */
  public final void generateCards ()
  {
    m_aCards = new BigInteger [m_nCardamount] [m_nCandidates];

    final SecureRandom randomGenerator = VerySecureRandom.getInstance ();
    for (int i = 1; i <= m_nCardamount; ++i)
    {
      // generate 9digit number
      final int randomInt = randomGenerator.nextInt (899999999) + 100000000;
      for (int j = 1; j <= m_nCandidates; ++j)
      {
        m_aCards[i - 1][j - 1] = new BigInteger (Integer.toString (j) + Integer.toString (randomInt));
        // System.out.println("Generated : " + j+randomInt);
      }
    }

  }

  /**
   * generate Blinding factor
   */
  public final void generateBlindingFactors ()
  {

    r = new BigInteger [m_nCardamount];

    for (int i = 1; i <= m_nCardamount; ++i)
    {

      BigInteger rrand = null;
      BigInteger gcd = null;
      final BigInteger one = new BigInteger ("1");

      final SecureRandom random = new SecureRandom ();

      // check that gcd(r,n) = 1 && r < n && r > 1
      do
      {
        final byte [] randomBytes = new byte [124];
        random.nextBytes (randomBytes);
        rrand = new BigInteger (1, randomBytes);
        gcd = rrand.gcd (m_aMod);
        // System.out.println("gcd: " + gcd);
        r[i - 1] = rrand;
      } while (!gcd.equals (one) || rrand.compareTo (m_aMod) >= 0 || rrand.compareTo (one) <= 0);
    }
  }

  /**
   * create rprim from r
   */
  public final void generateUnblindingFactors ()
  {
    rprim = new BigInteger [r.length];

    for (int i = 1; i <= r.length; ++i)
    {
      rprim[i - 1] = r[i - 1].modInverse (m_aMod);
    }
  }

  /**
   * set final r and clear this r before send vector of requested r.
   *
   * @param norequest
   *        Request counts
   */
  public void setRfinal (final int norequest)
  {
    if (m_aRfinal == null && norequest >= 0 && norequest <= m_nCandidates)
    {
      m_aRfinal = rprim[norequest];
      rprim[norequest] = BigInteger.ZERO;
    }
    else
      System.out.println ("ERROR: rfinal set before!");
  }

  /**
   * set signed card generated by VotingServer
   *
   * @param signedCard
   *        signed card
   */
  public void setSignedCard (final BigInteger [] signedCard)
  {
    this.m_aSignedCard = signedCard;
  }

  /**
   * send encodedCards to VotingServer
   *
   * @return encoded carts
   */
  public final BigInteger [] [] getCodedCards ()
  {
    return m_aEncodedCards;
  }

  /**
   * send rprim to VotingServer
   *
   * @return rprim or <code>null</code>
   */
  public BigInteger [] getRprim ()
  {

    // if rfinal != null means that rfinal is set and rprim is cleaned from
    // rfinal
    if (m_aRfinal != null)
      return rprim;
    return null;
  }

  /**
   * encode cards to "codecards" for acceptable to send to VotingServer
   */
  public final void encodeCards ()
  {

    m_aEncodedCards = new BigInteger [m_nCardamount] [m_nCandidates];

    for (int i = 1; i <= m_nCardamount; ++i)
    {
      for (int j = 1; j <= m_nCandidates; ++j)
      {
        final BigInteger re = r[i - 1].modPow (m_aE, m_aMod);
        m_aEncodedCards[i - 1][j - 1] = m_aCards[i - 1][j - 1].multiply (re).mod (m_aMod);// multiply(re).mod(mod);
        // System.out.println("Generated : " + j+randomInt);
      }
    }
  }

  /**
   * remove rprim from signed card
   */
  public void decodeCard ()
  {
    for (int j = 1; j <= m_nCandidates; ++j)
    {
      m_aSignedCard[j - 1] = m_aSignedCard[j - 1].multiply (m_aRfinal).mod (m_aMod);
    }
  }

  /**
   * send vote to VotingServer
   *
   * @param candidate
   *        number of candidate on which you voting.
   * @return signed value or <code>null</code>
   */
  public BigInteger sendVote (final int candidate)
  {
    if (m_aSignedCard != null)
    {
      decodeCard ();
      return m_aSignedCard[candidate];
    }
    return null;
  }

  /**
   * inform Voter if vote is accepted or not
   *
   * @param bAccepted
   *        accepted?
   */
  public void isVoteAccepted (final boolean bAccepted)
  {
    if (bAccepted)
    {
      System.out.println ("GLOS ZOSTA≈Å DODANY");
      // add confirm information here
    }
    else
    {
      System.out.println ("WYSTAPIL BLAD Z DODANIEM GLOSU!");
      // add reject information here
    }
  }

}

package blindsignature;

import java.math.BigInteger;

/**
 * VotingServer is a server-side of blind signature voting module.
 *
 * @author Pawel Maniora
 */
public class VotingServer
{

  /**
   * number of candidates on voting cards
   */
  private final int candidates;

  /**
   * numbers of cards - the higher amount - the safer and slower voting is.
   */
  private final int cardamount;

  /**
   * private key decriptor used to sign an decrypt votes
   */
  private final BigInteger d;

  /**
   * public key encriptor. everybody who wants use it to encrypt message
   */
  public BigInteger e;

  /**
   * modulus used in encryption/decryption. everybody who wants use it
   */
  public BigInteger mod;

  /**
   * number of voting card which is typed to not be checked and if everything
   * will be ok with others to be signed
   */
  public Integer norequest;

  /**
   * all coded cards sended from client
   */
  private BigInteger [] [] codedcards;

  /**
   * Voting Server constructor
   */
  VotingServer (final int candidates,
                final int cardamount,
                final BigInteger d,
                final BigInteger e,
                final BigInteger mod)
  {
    this.candidates = candidates;
    this.cardamount = cardamount;
    this.d = d;
    this.e = e;
    this.mod = mod;
    this.norequest = null;
    this.codedcards = null;
  }

  /**
   * Set Coded cards generated by client
   */
  public void setCodedCards (final BigInteger [] [] codedcards)
  {
    if (this.codedcards == null)
      this.codedcards = codedcards;
  }

  /**
   * Randomly choose @see #cardamount
   */
  public int drawNoRequest ()
  {
    if (norequest == null)
      norequest = (int) (Math.random () * (cardamount));
    return norequest;
  }

  /**
   * The method check if format of cards are correct - if all without random one
   * are correct - it means that one left in very high probablility is also
   * correct
   *
   * @param rprim
   *        - set of r^-1 mod(mod) used to unblind @see #codedcards
   */
  public boolean checkCards (final BigInteger [] rprim)
  {

    String cardpattern = "";

    for (Integer i = 1; i <= cardamount; ++i)
    {
      if (!i.equals (norequest + 1))
      {
        for (int j = 1; j <= candidates; ++j)
        {
          codedcards[i - 1][j - 1] = codedcards[i - 1][j - 1].modPow (d, mod)
                                                             .multiply (rprim[i - 1])
                                                             .mod (mod)
                                                             .modPow (e, mod);// multiply(rprimd).mod(mod);
          final String cleancard = codedcards[i - 1][j - 1].toString ();

          // check if votes have correct length
          if (cleancard.length () != 10)
          {
            System.out.println ("WRONG! CARD LENGTH!");
            return false;
          }

          // card pattern to check if every vote on votingcard has the same
          // number
          if (j == 1)
            cardpattern = cleancard.substring (1);

          final String cardnumber = cleancard.substring (1);
          if (cardnumber.compareTo (cardpattern) != 0)
          {
            System.out.println ("WRONG! NOT EQUAL NUMBERS!");
            return false;
          }

          // check if on cards have correct candidates
          final String cand = Character.toString (cleancard.charAt (0)); // candidate
                                                                         // number
          if (Integer.toString (j).compareTo (cand) != 0)
          {
            System.out.println ("WRONG BAD CANDIDATE NUMBER!");
            return false;
          }
        }
      }

    }
    return true;
  }

  /**
   * Sign card using blind vote
   */
  public BigInteger [] signCard ()
  {

    if (norequest != null)
    {
      final BigInteger [] signedCard = new BigInteger [candidates];
      for (int j = 1; j <= candidates; ++j)
        signedCard[j - 1] = codedcards[norequest][j - 1].modPow (d, mod);
      return signedCard;
    }
    return null;
  }

  /**
   * check if vote after encrypt is formated correctly (if it is it means that
   * vote was decrypted by private key of VotingServer)
   */
  public boolean checkVote (BigInteger vote)
  {

    vote = vote.modPow (e, mod);
    final int candidate = Integer.parseInt (Character.toString (vote.toString ().charAt (0)));
    // check here if vote is unique (in database)
    if (vote.toString ().length () == 10 && candidate <= candidates && candidate >= 0)
    {

      collectVote (vote);
      return true;

    }
    System.out.println ("VOTE INCORRECT!:" + vote.toString ());
    return false;

  }

  /**
   * add vote to database
   */
  private void collectVote (final BigInteger vote)
  {

    // add here function to add vote to database
    System.out.println ("VOTE:" + vote + " ADDED TO DATABASE.");
  }
}

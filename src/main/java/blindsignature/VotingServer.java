package blindsignature;

import java.math.BigInteger;

/**
 * VotingServer is a server-side of blind signature voting module.
 *
 * @author Pawel Maniora
 */
public class VotingServer
{

  /**
   * number of candidates on voting cards
   */
  private final int m_nCandidates;

  /**
   * numbers of cards - the higher amount - the safer and slower voting is.
   */
  private final int m_nCardamount;

  /**
   * private key decriptor used to sign an decrypt votes
   */
  private final BigInteger m_aD;

  /**
   * public key encriptor. everybody who wants use it to encrypt message
   */
  public BigInteger m_aE;

  /**
   * modulus used in encryption/decryption. everybody who wants use it
   */
  public BigInteger m_aMod;

  /**
   * number of voting card which is typed to not be checked and if everything
   * will be ok with others to be signed
   */
  public Integer m_aNorequest;

  /**
   * all coded cards sended from client
   */
  private BigInteger [] [] m_aCodedcards;

  /**
   * Voting Server constructor
   */
  VotingServer (final int candidates,
                final int cardamount,
                final BigInteger d,
                final BigInteger e,
                final BigInteger mod)
  {
    this.m_nCandidates = candidates;
    this.m_nCardamount = cardamount;
    this.m_aD = d;
    this.m_aE = e;
    this.m_aMod = mod;
    this.m_aNorequest = null;
    this.m_aCodedcards = null;
  }

  /**
   * Set Coded cards generated by client
   */
  public void setCodedCards (final BigInteger [] [] codedcards)
  {
    if (this.m_aCodedcards == null)
      this.m_aCodedcards = codedcards;
  }

  /**
   * Randomly choose @see #cardamount
   */
  public int drawNoRequest ()
  {
    if (m_aNorequest == null)
      m_aNorequest = Integer.valueOf ((int) (Math.random () * m_nCardamount));
    return m_aNorequest.intValue ();
  }

  /**
   * The method check if format of cards are correct - if all without random one
   * are correct - it means that one left in very high propablility is also
   * correct
   *
   * @param rprim
   *        - set of r^-1 mod(mod) used to unblind @see #codedcards
   */
  public boolean checkCards (final BigInteger [] rprim)
  {
    String cardpattern = "";

    for (int i = 1; i <= m_nCardamount; ++i)
    {
      if (i != m_aNorequest.intValue () + 1)
      {
        for (int j = 1; j <= m_nCandidates; ++j)
        {
          m_aCodedcards[i - 1][j - 1] = m_aCodedcards[i - 1][j - 1].modPow (m_aD, m_aMod)
                                                                   .multiply (rprim[i - 1])
                                                                   .mod (m_aMod)
                                                                   .modPow (m_aE, m_aMod);// multiply(rprimd).mod(mod);
          final String cleancard = m_aCodedcards[i - 1][j - 1].toString ();

          // check if votes have correct length
          if (cleancard.length () != 10)
          {
            System.out.println ("WRONG! CARD LENGTH!");
            return false;
          }

          // card pattern to check if every vote on votingcard has the same
          // number
          if (j == 1)
            cardpattern = cleancard.substring (1);

          final String cardnumber = cleancard.substring (1);
          if (cardnumber.compareTo (cardpattern) != 0)
          {
            System.out.println ("WRONG! NOT EQUAL NUMBERS!");
            return false;
          }

          // check if on cards have correct candidates
          final String cand = Character.toString (cleancard.charAt (0)); // candidate
                                                                         // number
          if (Integer.toString (j).compareTo (cand) != 0)
          {
            System.out.println ("WRONG BAD CANDIDATE NUMBER!");
            return false;
          }
        }
      }

    }
    return true;
  }

  /**
   * Sign card using blind vote
   */
  public BigInteger [] signCard ()
  {
    if (m_aNorequest != null)
    {
      final BigInteger [] signedCard = new BigInteger [m_nCandidates];
      for (int j = 1; j <= m_nCandidates; ++j)
        signedCard[j - 1] = m_aCodedcards[m_aNorequest.intValue ()][j - 1].modPow (m_aD, m_aMod);
      return signedCard;
    }
    return null;
  }

  /**
   * check if vote after encrypt is formated correctly (if it is it means that
   * vote was decrypted by private key of VotingServer)
   */
  public boolean checkVote (final BigInteger aOrigVote)
  {
    final BigInteger aVote = aOrigVote.modPow (m_aE, m_aMod);
    final int candidate = Integer.parseInt (Character.toString (aVote.toString ().charAt (0)));
    // check here if vote is unique (in database)
    if (aVote.toString ().length () == 10 && candidate <= m_nCandidates && candidate >= 0)
    {
      collectVote (aVote);
      return true;
    }
    System.out.println ("VOTE INCORRECT!:" + aVote.toString ());
    return false;
  }

  /**
   * add vote to database
   */
  private void collectVote (final BigInteger vote)
  {
    // add here function to add vote to database
    System.out.println ("VOTE:" + vote + " ADDED TO DATABASE.");
  }
}
